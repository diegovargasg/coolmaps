<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Digital Twin - Frankfurt Skyline</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script src="js/three.min.js"></script>
    <script src="js/geolib.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  </head>
  <body>
    <div id="map"></div>
    <script type="module">
      import { GUI } from "./js/lil-gui.module.min.js"
      import { Sky } from "./js/Sky.js"
      import Stats from "./js/stats.module.js"

      let camera,
        controls,
        scene,
        renderer,
        map,
        group,
        sky,
        sun,
        stats,
        groundMesh
      let buildingsGeometry = []
      let waterGeometry = []
      let grassGeometry = []
      let highwayGeometry = []

      let MAT_BUILDING, MAT_ROAD
      let center = [8.673, 50.10690781920793]

      function init() {
        map = document.getElementById("map")
        scene = new THREE.Scene()

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        )
        camera.position.set(5, 8, 3)
        camera.position.z = 5

        group = new THREE.Group()
        group.name = "Interactive Root"

        scene.add(group)

        // SUN LIGHT
        const sunLight = new THREE.DirectionalLight(0xffffff, 1)
        sunLight.position.set(30, 10, 50)
        sunLight.castShadow = true
        scene.add(sunLight)

        // const helper = new THREE.DirectionalLightHelper(sunLight)
        // scene.add(helper)

        // GROUND
        const groundGeo = new THREE.PlaneGeometry(28, 37)
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x0c1015 })

        const ground = new THREE.Mesh(groundGeo, groundMat)
        ground.position.y = 0
        ground.rotation.x = -Math.PI / 2
        ground.receiveShadow = true
        scene.add(ground)

        let ambientLight = new THREE.AmbientLight(0xfafafa, 0.25)
        scene.add(ambientLight)

        // SKY AND SUN
        sun = new THREE.Vector3()

        sky = new Sky()
        sky.scale.setScalar(450000)
        scene.add(sky)

        // GRID HELPER
        // const gridHelper = new THREE.GridHelper(
        //   40,
        //   10,
        //   new THREE.Color(0x555555),
        //   new THREE.Color(0x333333)
        // )
        // scene.add(gridHelper)

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.outputEncoding = THREE.sRGBEncoding
        renderer.toneMapping = THREE.ACESFilmicToneMapping
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        map.appendChild(renderer.domElement)

        controls = new THREE.OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.25
        controls.screenSpacePanning = false
        controls.minDistance = 1
        controls.maxDistance = 800
        window.addEventListener("resize", onWindowResize)

        MAT_BUILDING = new THREE.MeshPhongMaterial()
        MAT_ROAD = new THREE.LineDashedMaterial({ color: 0xfde293 })

        // STATS
        // stats = new Stats()
        // map.appendChild(stats.dom)

        getBuildings()
        getSurroundings()
        initSky()
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate() {
        requestAnimationFrame(animate)
        render()
        //stats.update()
        controls.update() // only required if controls.enableDamping = true, or if controls.autoRotate = true
      }

      function render() {
        renderer.render(scene, camera)
      }

      function initSky() {
        // Add Sky
        sky = new Sky()
        sky.scale.setScalar(450000)
        scene.add(sky)

        sun = new THREE.Vector3()

        /// GUI
        const effectController = {
          turbidity: 10,
          rayleigh: 3,
          mieCoefficient: 0.005,
          mieDirectionalG: 0.7,
          elevation: 2,
          //azimuth: 180,
          azimuth: 30,
          exposure: renderer.toneMappingExposure
        }

        function guiChanged() {
          const uniforms = sky.material.uniforms
          uniforms["turbidity"].value = effectController.turbidity
          uniforms["rayleigh"].value = effectController.rayleigh
          uniforms["mieCoefficient"].value = effectController.mieCoefficient
          uniforms["mieDirectionalG"].value = effectController.mieDirectionalG

          const phi = THREE.MathUtils.degToRad(90 - effectController.elevation)
          const theta = THREE.MathUtils.degToRad(effectController.azimuth)

          sun.setFromSphericalCoords(1, phi, theta)

          uniforms["sunPosition"].value.copy(sun)

          renderer.toneMappingExposure = effectController.exposure
          renderer.render(scene, camera)
        }

        const gui = new GUI()

        gui
          .add(effectController, "turbidity", 0.0, 20.0, 0.1)
          .onChange(guiChanged)
        gui
          .add(effectController, "rayleigh", 0.0, 4, 0.001)
          .onChange(guiChanged)
        gui
          .add(effectController, "mieCoefficient", 0.0, 0.1, 0.001)
          .onChange(guiChanged)
        gui
          .add(effectController, "mieDirectionalG", 0.0, 1, 0.001)
          .onChange(guiChanged)
        gui.add(effectController, "elevation", 0, 90, 0.1).onChange(guiChanged)
        gui
          .add(effectController, "azimuth", -180, 180, 0.1)
          .onChange(guiChanged)
        gui.add(effectController, "exposure", 0, 1, 0.0001).onChange(guiChanged)

        guiChanged()
      }

      function getSurroundings() {
        fetch("./resources/frankfurt-surroundings.geojson").then((resp) => {
          resp.json().then((data) => {
            loadSurroundings(data)
          })
        })
      }

      function loadSurroundings(data) {
        data.features.forEach((element) => {
          if (!element["properties"]) return

          if (element.geometry.type === "Polygon") {
            if (element.properties["water"]) {
              addSurrounding(
                element.geometry.coordinates,
                element.properties,
                "water"
              )
            } else {
              addSurrounding(
                element.geometry.coordinates,
                element.properties,
                "grass"
              )
            }
          } else if (
            element.geometry.type === "LineString" &&
            element.properties["highway"] &&
            (element.properties["highway"] === "primary" ||
              element.properties["highway"] === "secondary" ||
              element.properties["highway"] === "tertiary" ||
              element.properties["highway"] === "residential")
          ) {
            addRoad(element.geometry.coordinates, element.properties, "highway")
          }
        })

        let waterColor = 0x9cc0f9
        let grassColor = 0xb9e0c4
        let highwayColor = 0xd0938e

        let mergeGeometry =
          THREE.BufferGeometryUtils.mergeBufferGeometries(waterGeometry)
        const material = new THREE.MeshPhongMaterial({ color: waterColor })
        let mesh = new THREE.Mesh(mergeGeometry, material)
        mesh.receiveShadow = true
        group.add(mesh)

        let mergeGrassGeometry =
          THREE.BufferGeometryUtils.mergeBufferGeometries(grassGeometry)
        const grassMaterial = new THREE.MeshPhongMaterial({ color: grassColor })
        let grassMesh = new THREE.Mesh(mergeGrassGeometry, grassMaterial)
        grassMesh.receiveShadow = true
        group.add(grassMesh)
      }

      function addSurrounding(coordinates, properties, type) {
        let shape, geometry
        let gaps = []

        coordinates.forEach((coordinate, index) => {
          if (index === 0) {
            shape = generateShape(coordinate, center)
          } else {
            gaps.push(generateShape(coordinate, center))
          }
        })

        gaps.forEach((gap) => {
          shape.holes.push(gap)
        })

        geometry = generateGeometry(shape, {
          curveSegments: 1,
          depth: 0.01,
          bevelEnabled: false
        })

        geometry.rotateX(Math.PI / 2)
        geometry.rotateZ(Math.PI)

        if (type === "water") {
          waterGeometry.push(geometry)
        } else {
          grassGeometry.push(geometry)
        }
      }

      function addRoad(coordinates, properties) {
        let points = []

        coordinates.forEach((coordinate) => {
          //if(!coordinate[0][1]) return

          let el = coordinate

          if (!el[0] || !el[1]) return

          let elp = [el[0], el[1]]

          elp = GPSRelativePositionTurf([elp[0], elp[1]], center)

          points.push(new THREE.Vector3(elp[0], 0.5, elp[1]))
        })

        let geometry = new THREE.BufferGeometry().setFromPoints(points)

        // Adjust geometry rotation
        geometry.rotateZ(Math.PI)

        let line = new THREE.Line(geometry, MAT_ROAD)
        //line.info = info
        line.computeLineDistances()

        group.add(line)
        line.position.set(line.position.x, 0.5, line.position.z)
      }

      function getBuildings() {
        fetch("./resources/frankfurt-skyline.geojson").then((resp) => {
          resp.json().then((data) => {
            loadBuildings(data)
          })
        })
      }

      function loadBuildings(data) {
        data.features.forEach((element) => {
          if (!element["properties"]) return

          if (
            element.properties["building"] !== "no" &&
            element.geometry.type === "Polygon"
          ) {
            addBuilding(
              element.geometry.coordinates,
              element.properties,
              element.properties["building:levels"]
            )
          }
        })

        let mergeGeometry =
          THREE.BufferGeometryUtils.mergeBufferGeometries(buildingsGeometry)
        let mesh = new THREE.Mesh(mergeGeometry, MAT_BUILDING)
        mesh.receiveShadow = true
        mesh.castShadow = true
        group.add(mesh)
      }

      function addBuilding(coordinates, properties, height = 1) {
        height = height ? height : 1
        let shape, geometry
        let gaps = []

        coordinates.forEach((coordinate, index) => {
          if (index === 0) {
            shape = generateShape(coordinate, center)
          } else {
            gaps.push(generateShape(coordinate, center))
          }
        })

        gaps.forEach((gap) => {
          shape.holes.push(gap)
        })

        geometry = generateGeometry(shape, {
          curveSegments: 1,
          depth: 0.05 * height,
          bevelEnabled: false
        })

        geometry.rotateX(Math.PI / 2)
        geometry.rotateZ(Math.PI)

        buildingsGeometry.push(geometry)
      }

      function generateShape(coordinate, center) {
        let shape = new THREE.Shape()

        //if(typeof coordinate === "object") {
        coordinate.forEach((element, index) => {
          let elPosition = GPSRelativePositionTurf(element, center)
          if (index === 0) {
            shape.moveTo(elPosition[0], elPosition[1])
          } else {
            shape.lineTo(elPosition[0], elPosition[1])
          }
        })
        //}

        return shape
      }

      function GPSRelativePosition(objPosi, centerPosi) {
        // Get GPS distance
        let dis = window.geolib.getDistance(objPosi, centerPosi)

        // Get bearing angle
        let bearing = window.geolib.getRhumbLineBearing(objPosi, centerPosi)

        // Calculate X by centerPosi.x + distance * cos(rad)
        let x = centerPosi[0] + dis * Math.cos((bearing * Math.PI) / 180)

        // Calculate Y by centerPosi.y + distance * sin(rad)
        let y = centerPosi[1] + dis * Math.sin((bearing * Math.PI) / 180)

        // Reverse X (it work)
        return [-x / 100, y / 100]
      }

      function GPSRelativePositionTurf(objPosi, centerPosi) {
        let options = { units: "meters" }

        // Get GPS distance
        let dis = turf.distance(objPosi, centerPosi, options)

        // Get bearing angle
        let bearing = turf.rhumbBearing(objPosi, centerPosi)

        // Calculate X by centerPosi.x + distance * cos(rad)
        let x = centerPosi[0] + dis * Math.cos((bearing * Math.PI) / 180)

        // Calculate Y by centerPosi.y + distance * sin(rad)
        let y = centerPosi[1] + dis * Math.sin((bearing * Math.PI) / 180)

        // Reverse X (it work)
        return [-x / 100, y / 100]
      }

      function generateGeometry(shape, settings) {
        let geometry = new THREE.ExtrudeGeometry(shape, settings)
        geometry.computeBoundingBox()
        return geometry
      }

      init()
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate()
    </script>
  </body>
</html>
