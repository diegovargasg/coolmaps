<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Digital Twin - Frankfurt Skyline</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script src="js/three.min.js"></script>
    <script src="js/geolib.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  </head>
  <body>
    <div id="map"></div>
    <script>
      //  const openWeather = "https://api.open-meteo.com/v1/forecast?latitude=50.1211&longitude=8.6605&current_weather=true";
      //   const openWeather =
      //     "https://api.openweathermap.org/data/3.0/onecall?lat=50.1211&lon=8.6605&appid=97cd4a7b5ac79db1ad25ffd46a7a1bb0"
      //   const response = {
      //     lat: 39.31,
      //     lon: -74.5,
      //     timezone: "America/New_York",
      //     timezone_offset: -18000,
      //     current: {
      //       dt: 1646318698,
      //       sunrise: 1646306882,
      //       sunset: 1646347929,
      //       temp: 282.21,
      //       feels_like: 278.41,
      //       pressure: 1014,
      //       humidity: 65,
      //       dew_point: 275.99,
      //       uvi: 2.55,
      //       clouds: 40,
      //       visibility: 10000,
      //       wind_speed: 8.75,
      //       wind_deg: 360,
      //       wind_gust: 13.89,
      //       weather: [
      //         {
      //           id: 802,
      //           main: "Clouds",
      //           description: "scattered clouds",
      //           icon: "03d"
      //         }
      //       ]
      //     }
      //   }
      //   // Make a request for a user with a given ID
      //   axios
      //     .get(openWeather)
      //     .then(function (response) {
      //       // handle success
      //       console.log(response)
      //     })
      //     .catch(function (error) {
      //       // handle error
      //       console.log(error)
      //     })
      //     .finally(function () {
      //       // always executed
      //     })
    </script>
    <script>
      let camera, controls, scene, renderer, map, group
      let buildingsGeometry = []

      let MAT_BUILDING
      let center = [8.661569309005895, 50.105860364457655]

      function init() {
        map = document.getElementById("map")
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0x22222)

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        )
        camera.position.set(8, 4, 0)
        camera.position.z = 5

        group = new THREE.Group()
        group.name = "Interactive Root"

        scene.add(group)

        let light0 = new THREE.AmbientLight(0xfafafa, 0.25)

        let light1 = new THREE.PointLight(0xfafafa, 0.4)
        light1.position.set(200, 90, 40)

        let light2 = new THREE.PointLight(0xfafafa, 0.4)
        light2.position.set(200, 90, -40)

        scene.add(light0)
        scene.add(light1)
        scene.add(light2)

        let gridHelper = new THREE.GridHelper(
          60,
          160,
          new THREE.Color(0x555555),
          new THREE.Color(0x333333)
        )
        scene.add(gridHelper)

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)

        map.appendChild(renderer.domElement)

        controls = new THREE.OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.25
        controls.screenSpacePanning = false
        controls.minDistance = 10
        controls.maxDistance = 100

        window.addEventListener("resize", onWindowResize)

        MAT_BUILDING = new THREE.MeshPhongMaterial()
        getData()
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate() {
        requestAnimationFrame(animate)
        render()
        controls.update() // only required if controls.enableDamping = true, or if controls.autoRotate = true
      }

      function render() {
        renderer.render(scene, camera)
      }

      function getData() {
        fetch("./resources/frankfurt-skyline.geojson").then((resp) => {
          resp.json().then((data) => {
            loadBuildings(data)
          })
        })
      }

      function loadBuildings(data) {
        data.features.forEach((element) => {
          if (!element["properties"]) return

          if (
            element.properties["building"] !== "no" &&
            element.geometry.type === "Polygon"
          ) {
            addBuilding(
              element.geometry.coordinates,
              element.properties,
              element.properties["building:levels"]
            )
          }
        })

        let mergeGeometry =
          THREE.BufferGeometryUtils.mergeBufferGeometries(buildingsGeometry)
        let mesh = new THREE.Mesh(mergeGeometry, MAT_BUILDING)
        group.add(mesh)
      }

      function addBuilding(coordinates, properties, height = 1) {
        height = height ? height : 1
        let shape, geometry
        let gaps = []

        coordinates.forEach((coordinate, index) => {
          if (index === 0) {
            shape = generateShape(coordinate, center)
          } else {
            gaps.push(generateShape(coordinate, center))
          }
        })

        gaps.forEach((gap) => {
          shape.holes.push(gap)
        })

        geometry = generateGeometry(shape, {
          curveSegments: 1,
          depth: 0.05 * height,
          bevelEnabled: false
        })

        geometry.rotateX(Math.PI / 2)
        geometry.rotateZ(Math.PI)

        buildingsGeometry.push(geometry)

        let helper = generateHelper(geometry)

        if (helper) {
          helper.name = properties["name"] ? properties["name"] : "Building"
          helper.info = properties
          scene.add(helper)
        }
      }

      function generateHelper(geometry) {
        if (!geometry.boundingBox) {
          geometry.computeBoundingBox()
        }

        let box3 = geometry.boundingBox

        if (!isFinite(box3.max.x)) {
          return false
        }

        let helper = new THREE.Box3Helper(box3, 0xffff00)
        return helper
      }

      function generateShape(coordinate, center) {
        let shape = new THREE.Shape()

        //if(typeof coordinate === "object") {
        coordinate.forEach((element, index) => {
          elPosition = GPSRelativePositionTurf(element, center)
          if (index === 0) {
            shape.moveTo(elPosition[0], elPosition[1])
          } else {
            shape.lineTo(elPosition[0], elPosition[1])
          }
        })
        //}

        return shape
      }

      function GPSRelativePosition(objPosi, centerPosi) {
        // Get GPS distance
        let dis = window.geolib.getDistance(objPosi, centerPosi)

        // Get bearing angle
        let bearing = window.geolib.getRhumbLineBearing(objPosi, centerPosi)

        // Calculate X by centerPosi.x + distance * cos(rad)
        let x = centerPosi[0] + dis * Math.cos((bearing * Math.PI) / 180)

        // Calculate Y by centerPosi.y + distance * sin(rad)
        let y = centerPosi[1] + dis * Math.sin((bearing * Math.PI) / 180)

        // Reverse X (it work)
        return [-x / 100, y / 100]
      }

      function GPSRelativePositionTurf(objPosi, centerPosi) {
        let options = { units: "meters" }

        // Get GPS distance
        let dis = turf.distance(objPosi, centerPosi, options)

        // Get bearing angle
        let bearing = turf.rhumbBearing(objPosi, centerPosi)

        // Calculate X by centerPosi.x + distance * cos(rad)
        let x = centerPosi[0] + dis * Math.cos((bearing * Math.PI) / 180)

        // Calculate Y by centerPosi.y + distance * sin(rad)
        let y = centerPosi[1] + dis * Math.sin((bearing * Math.PI) / 180)

        // Reverse X (it work)
        return [-x / 100, y / 100]
      }

      function generateGeometry(shape, settings) {
        let geometry = new THREE.ExtrudeGeometry(shape, settings)
        geometry.computeBoundingBox()
        return geometry
      }

      init()
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate()
    </script>
  </body>
</html>
