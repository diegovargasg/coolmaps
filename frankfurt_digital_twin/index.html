<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Digital Twin - Frankfurt Skyline</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script src="js/three.min.js"></script>
    <script src="js/geolib.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  </head>
  <body>
    <div id="map"></div>
    <script>
      //  const openWeather = "https://api.open-meteo.com/v1/forecast?latitude=50.1211&longitude=8.6605&current_weather=true";
      //   const openWeather =
      //     "https://api.openweathermap.org/data/3.0/onecall?lat=50.1211&lon=8.6605&appid=97cd4a7b5ac79db1ad25ffd46a7a1bb0"
      //   const response = {
      //     lat: 39.31,
      //     lon: -74.5,
      //     timezone: "America/New_York",
      //     timezone_offset: -18000,
      //     current: {
      //       dt: 1646318698,
      //       sunrise: 1646306882,
      //       sunset: 1646347929,
      //       temp: 282.21,
      //       feels_like: 278.41,
      //       pressure: 1014,
      //       humidity: 65,
      //       dew_point: 275.99,
      //       uvi: 2.55,
      //       clouds: 40,
      //       visibility: 10000,
      //       wind_speed: 8.75,
      //       wind_deg: 360,
      //       wind_gust: 13.89,
      //       weather: [
      //         {
      //           id: 802,
      //           main: "Clouds",
      //           description: "scattered clouds",
      //           icon: "03d"
      //         }
      //       ]
      //     }
      //   }
      //   // Make a request for a user with a given ID
      //   axios
      //     .get(openWeather)
      //     .then(function (response) {
      //       // handle success
      //       console.log(response)
      //     })
      //     .catch(function (error) {
      //       // handle error
      //       console.log(error)
      //     })
      //     .finally(function () {
      //       // always executed
      //     })
    </script>
    <script>
      let camera, controls, scene, renderer, map, group
      let buildingsGeometry = []
      let waterGeometry = []
      let grassGeometry = []
      let highwayGeometry = []

      let MAT_BUILDING, MAT_ROAD
      let center = [8.66342267271418, 50.10690781920793]

      function init() {
        map = document.getElementById("map")
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0x22222)

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        )
        camera.position.set(0, 10, 0)
        camera.position.z = 5

        group = new THREE.Group()
        group.name = "Interactive Root"

        scene.add(group)

        let light0 = new THREE.AmbientLight(0xfafafa, 0.25)

        let light1 = new THREE.PointLight(0xfafafa, 0.4)
        light1.position.set(200, 90, 40)

        let light2 = new THREE.PointLight(0xfafafa, 0.4)
        light2.position.set(200, 90, -40)

        scene.add(light0)
        scene.add(light1)
        scene.add(light2)

        let gridHelper = new THREE.GridHelper(
          40,
          10,
          new THREE.Color(0x555555),
          new THREE.Color(0x333333)
        )
        //scene.add(gridHelper)

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)

        map.appendChild(renderer.domElement)

        controls = new THREE.OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.25
        controls.screenSpacePanning = false
        controls.minDistance = 1
        controls.maxDistance = 800
        window.addEventListener("resize", onWindowResize)

        MAT_BUILDING = new THREE.MeshPhongMaterial()
        MAT_ROAD = new THREE.LineDashedMaterial( { color: 0xfde293 } )
        //MAT_BUILDING = new THREE.MeshBasicMaterial()
        getBuildings()
        getWater()
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate() {
        requestAnimationFrame(animate)
        render()
        controls.update() // only required if controls.enableDamping = true, or if controls.autoRotate = true
      }

      function render() {
        renderer.render(scene, camera)
      }

      function getWater() {
        fetch("./resources/frankfurt-surroundings.geojson").then((resp) => {
          resp.json().then((data) => {
            loadWater(data)
          })
        })
      }

      function loadWater(data) {
        data.features.forEach((element) => {
          if (!element["properties"]) return

          if (element.geometry.type === "Polygon") {
            if (element.properties["water"]) {
              addWater(
                element.geometry.coordinates,
                element.properties,
                "water"
              )
            } else {
              addWater(
                element.geometry.coordinates,
                element.properties,
                "grass"
              )
              
            }
          } else if (element.geometry.type === "LineString" && element.properties["highway"] && (element.properties["highway"] === "primary" || element.properties["highway"] === "secondary" || element.properties["highway"] === "tertiary" || element.properties["highway"] === "residential")) {
            addRoad(
                element.geometry.coordinates,
                element.properties,
                "highway"
              )
          }
        })

        let waterColor = 0x9cc0f9
        let grassColor = 0xb9e0c4
        let highwayColor = 0xd0938e

        let mergeGeometry =
          THREE.BufferGeometryUtils.mergeBufferGeometries(waterGeometry)
        const material = new THREE.MeshPhongMaterial({ color: waterColor })
        let mesh = new THREE.Mesh(mergeGeometry, material)
        group.add(mesh)

        let mergeGrassGeometry =
          THREE.BufferGeometryUtils.mergeBufferGeometries(grassGeometry)
        const grassMaterial = new THREE.MeshPhongMaterial({ color: grassColor })
        let grassMesh = new THREE.Mesh(mergeGrassGeometry, grassMaterial)
        group.add(grassMesh)
      }

      function addWater(coordinates, properties, type) {
        let shape, geometry
        let gaps = []

        coordinates.forEach((coordinate, index) => {
          if (index === 0) {
            shape = generateShape(coordinate, center)
          } else {
            gaps.push(generateShape(coordinate, center))
          }
        })

        gaps.forEach((gap) => {
          shape.holes.push(gap)
        })

        geometry = generateGeometry(shape, {
          curveSegments: 1,
          depth: 0,
          bevelEnabled: false
        })

        geometry.rotateX(Math.PI / 2)
        geometry.rotateZ(Math.PI)

        if (type === "water") {
          waterGeometry.push(geometry)
        } else {
          grassGeometry.push(geometry)
        }
      }

      function addRoad(coordinates, properties) {
        let points = []

        coordinates.forEach(coordinate => {

          //if(!coordinate[0][1]) return
          
          let el = coordinate
          
          if(!el[0] || !el[1]) return

          let elp = [el[0], el[1]]

          elp = GPSRelativePositionTurf([elp[0], elp[1]], center)
          
          points.push( new THREE.Vector3( elp[0], 0.5, elp[1] ) )
        })


        let geometry = new THREE.BufferGeometry().setFromPoints( points )

        // Adjust geometry rotation
        geometry.rotateZ(Math.PI)

        let line = new THREE.Line( geometry, MAT_ROAD )
        //line.info = info
        line.computeLineDistances()

        group.add(line)
        line.position.set(line.position.x, 0.5, line.position.z)
      }

      function getBuildings() {
        fetch("./resources/frankfurt-skyline.geojson").then((resp) => {
          resp.json().then((data) => {
            loadBuildings(data)
          })
        })
      }

      function loadBuildings(data) {
        data.features.forEach((element) => {
          if (!element["properties"]) return

          if (
            element.properties["building"] !== "no" &&
            element.geometry.type === "Polygon"
          ) {
            addBuilding(
              element.geometry.coordinates,
              element.properties,
              element.properties["building:levels"]
            )
          }
        })

        let mergeGeometry =
          THREE.BufferGeometryUtils.mergeBufferGeometries(buildingsGeometry)
        let mesh = new THREE.Mesh(mergeGeometry, MAT_BUILDING)
        group.add(mesh)
      }

      function addBuilding(coordinates, properties, height = 1) {
        height = height ? height : 1
        let shape, geometry
        let gaps = []

        coordinates.forEach((coordinate, index) => {
          if (index === 0) {
            shape = generateShape(coordinate, center)
          } else {
            gaps.push(generateShape(coordinate, center))
          }
        })

        gaps.forEach((gap) => {
          shape.holes.push(gap)
        })

        geometry = generateGeometry(shape, {
          curveSegments: 1,
          depth: 0.05 * height,
          bevelEnabled: false
        })

        geometry.rotateX(Math.PI / 2)
        geometry.rotateZ(Math.PI)

        buildingsGeometry.push(geometry)
      }

      function generateShape(coordinate, center) {
        let shape = new THREE.Shape()

        //if(typeof coordinate === "object") {
        coordinate.forEach((element, index) => {
          elPosition = GPSRelativePositionTurf(element, center)
          if (index === 0) {
            shape.moveTo(elPosition[0], elPosition[1])
          } else {
            shape.lineTo(elPosition[0], elPosition[1])
          }
        })
        //}

        return shape
      }

      function GPSRelativePosition(objPosi, centerPosi) {
        // Get GPS distance
        let dis = window.geolib.getDistance(objPosi, centerPosi)

        // Get bearing angle
        let bearing = window.geolib.getRhumbLineBearing(objPosi, centerPosi)

        // Calculate X by centerPosi.x + distance * cos(rad)
        let x = centerPosi[0] + dis * Math.cos((bearing * Math.PI) / 180)

        // Calculate Y by centerPosi.y + distance * sin(rad)
        let y = centerPosi[1] + dis * Math.sin((bearing * Math.PI) / 180)

        // Reverse X (it work)
        return [-x / 100, y / 100]
      }

      function GPSRelativePositionTurf(objPosi, centerPosi) {
        let options = { units: "meters" }

        // Get GPS distance
        let dis = turf.distance(objPosi, centerPosi, options)

        // Get bearing angle
        let bearing = turf.rhumbBearing(objPosi, centerPosi)

        // Calculate X by centerPosi.x + distance * cos(rad)
        let x = centerPosi[0] + dis * Math.cos((bearing * Math.PI) / 180)

        // Calculate Y by centerPosi.y + distance * sin(rad)
        let y = centerPosi[1] + dis * Math.sin((bearing * Math.PI) / 180)

        // Reverse X (it work)
        return [-x / 100, y / 100]
      }

      function generateGeometry(shape, settings) {
        let geometry = new THREE.ExtrudeGeometry(shape, settings)
        geometry.computeBoundingBox()
        return geometry
      }

      init()
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate()
    </script>
  </body>
</html>
