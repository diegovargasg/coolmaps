<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GeoJSON 3D Deutsche Bahn Logo</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script src="js/three.min.js"></script>
    <script src="js/geolib.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/BufferGeometryUtils.js"></script>
    <script src="js/turf.min.js"></script>
    <script src="js/axios.min.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/Geometry.js"></script>
  </head>
  <body>
    <div id="mapContainer"></div>
    <script type="x-shader/x-vertex" id="vertexShader">
      varying vec3 vWorldPosition;
      void main() {
      	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      	vWorldPosition = worldPosition.xyz;
      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      varying vec3 vWorldPosition;
      void main() {
      	float h = normalize( vWorldPosition + offset ).y;
      	gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
      }
    </script>
    <script type="module">
      import Stats from "./js/stats.module.js";

      let camera, controls, scene, renderer, mapContainer, roadsGroup, surroudingsGroup, boxGroup, sphereGroup, pyramidGroup, sky, sun, water, stats, groundMesh;
      let boxGeometries = [];
      let center = [8.673, 50.10690781920793]; //Frankfurt
      let mouseX = 0,
        mouseY = 0;

      let windowHalfX = window.innerWidth / 2;
      let windowHalfY = window.innerHeight / 2;

      function init() {
        const container = document.getElementById("mapContainer");

        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 0, 350);

        scene = new THREE.Scene();
        scene.background = new THREE.Color().setHSL(0.6, 0, 1);
        scene.fog = new THREE.Fog(scene.background, 1, 5000);

        // ADD GEOMETRY GROUP

        boxGroup = new THREE.Group();
        boxGroup.name = "Buildings Group";

        scene.add(boxGroup);

        // LIGHTS

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        hemiLight.color.setHSL(0.6, 1, 0.6);
        hemiLight.groundColor.setHSL(0.095, 1, 0.75);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        // const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
        // scene.add( hemiLightHelper );

        //

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.color.setHSL(0.1, 1, 0.95);
        dirLight.position.set(0, 2, 2);
        dirLight.position.multiplyScalar(30);
        scene.add(dirLight);

        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;

        const d = 50;

        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;

        dirLight.shadow.camera.far = 3500;
        dirLight.shadow.bias = -0.0001;

        // const dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );
        // scene.add( dirLightHelper );

        // GROUND

        const groundGeo = new THREE.PlaneGeometry(10000, 10000);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        //groundMat.color.setHSL(0.095, 1, 0.75);

        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.position.y = -33;
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // SKYDOME

        const vertexShader = document.getElementById("vertexShader").textContent;
        const fragmentShader = document.getElementById("fragmentShader").textContent;
        const uniforms = {
          topColor: { value: new THREE.Color(0x0077ff) },
          bottomColor: { value: new THREE.Color(0xffffff) },
          offset: { value: 33 },
          exponent: { value: 0.6 },
        };
        uniforms["topColor"].value.copy(hemiLight.color);

        scene.fog.color.copy(uniforms["bottomColor"].value);

        const skyGeo = new THREE.SphereGeometry(4000, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          side: THREE.BackSide,
        });

        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);

        // RENDERER

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 50;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;

        // STATS

        stats = new Stats();
        container.appendChild(stats.dom);

        //

        window.addEventListener("resize", onWindowResize);
        document.addEventListener("mousemove", onDocumentMouseMove);
        getBuildings();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      function animate() {
        requestAnimationFrame(animate);
        boxGroup.rotation.y += 0.005;
        render();
        stats.update();
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
      }

      function render() {
        // camera.position.x += (mouseX - camera.position.x) * 0.009;
        // camera.position.y += (-mouseY - camera.position.y) * 0.009;

        // camera.lookAt(scene.position);

        renderer.render(scene, camera);
      }

      function getBuildings() {
        fetch("./resources/db-logo.geojson").then((resp) => {
          resp.json().then((data) => {
            loadBuildings(data, center);
          });
        });
      }

      function loadBuildings(data, centerP) {
        data.features.forEach((element, index) => {
          if (!element["properties"]) return;

          if (element.geometry.type === "Polygon") {
            const geometry = new Geometry(element.geometry.coordinates, element.properties, centerP);
            const geometryModel = geometry.generate();
            // const material = new THREE.MeshBasicMaterial({ color: element.properties.fill });
            // const meshBox = new THREE.Mesh(geometryModel, material);
            // meshBox.castShadow = true;
            // meshBox.receiveShadow = true;
            // scene.add(meshBox);
            boxGeometries.push(geometryModel);
          }
        });

        let material = new THREE.MeshPhongMaterial({ color: "#f01414" });
        let mergeBoxes = THREE.BufferGeometryUtils.mergeBufferGeometries(boxGeometries);
        let meshBox = new THREE.Mesh(mergeBoxes, material);
        meshBox.receiveShadow = true;
        meshBox.castShadow = true;
        boxGroup.add(meshBox);
      }

      init();
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate();
    </script>
  </body>
</html>
