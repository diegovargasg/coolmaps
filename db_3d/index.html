<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Deutsche Bahn Logo</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script src="js/three.min.js"></script>
    <script src="js/geolib.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/BufferGeometryUtils.js"></script>
    <script src="js/turf.min.js"></script>
    <script src="js/axios.min.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/Building.js"></script>
  </head>
  <body>
    <div id="mapContainer"></div>
    <script type="x-shader/x-vertex" id="vertexShader">
      varying vec3 vWorldPosition;
      void main() {
      	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      	vWorldPosition = worldPosition.xyz;
      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      varying vec3 vWorldPosition;
      void main() {
      	float h = normalize( vWorldPosition + offset ).y;
      	gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
      }
    </script>
    <script type="module">
      import Stats from "./js/stats.module.js";

      let camera, controls, scene, renderer, mapContainer, roadsGroup, surroudingsGroup, boxGroup, sphereGroup, pyramidGroup, sky, sun, water, stats, groundMesh;
      let center = [8.673, 50.10690781920793]; //Frankfurt

      function init() {
        const container = document.getElementById("mapContainer");

        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 0, 250);

        scene = new THREE.Scene();
        scene.background = new THREE.Color().setHSL(0.6, 0, 1);
        scene.fog = new THREE.Fog(scene.background, 1, 5000);

        // LIGHTS

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        hemiLight.color.setHSL(0.6, 1, 0.6);
        hemiLight.groundColor.setHSL(0.095, 1, 0.75);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        //

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.color.setHSL(0.1, 1, 0.95);
        dirLight.position.set(-1, 1.75, 1);
        dirLight.position.multiplyScalar(30);
        scene.add(dirLight);

        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;

        const d = 50;

        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;

        dirLight.shadow.camera.far = 3500;
        dirLight.shadow.bias = -0.0001;

        // GROUND

        const groundGeo = new THREE.PlaneGeometry(10000, 10000);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        groundMat.color.setHSL(0.095, 1, 0.75);

        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.position.y = -33;
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // SKYDOME

        const vertexShader = document.getElementById("vertexShader").textContent;
        const fragmentShader = document.getElementById("fragmentShader").textContent;
        const uniforms = {
          topColor: { value: new THREE.Color(0x0077ff) },
          bottomColor: { value: new THREE.Color(0xffffff) },
          offset: { value: 33 },
          exponent: { value: 0.6 },
        };
        uniforms["topColor"].value.copy(hemiLight.color);

        scene.fog.color.copy(uniforms["bottomColor"].value);

        const skyGeo = new THREE.SphereGeometry(4000, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          side: THREE.BackSide,
        });

        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);

        // RENDERER

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 1;
        controls.maxDistance = 800;
        // STATS

        stats = new Stats();
        container.appendChild(stats.dom);

        //

        window.addEventListener("resize", onWindowResize);
        getBuildings();
      }
      /*
      function init() {
        mapContainer = document.getElementById("mapContainer");
        scene = new THREE.Scene();
        scene.background = new THREE.Color().setHSL(0.6, 0, 1);
        scene.fog = new THREE.Fog(scene.background, 1, 5000);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 8, 3);
        camera.position.z = 5;

        // LIGHTS

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        hemiLight.color.setHSL(0.6, 1, 0.6);
        hemiLight.groundColor.setHSL(0.095, 1, 0.75);
        hemiLight.position.set(0, 50, 0);
        hemiLight.visible = true;
        scene.add(hemiLight);

        const hemiLightHelper = new THREE.HemisphereLightHelper(hemiLight, 10);
        scene.add(hemiLightHelper);

        //

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.color.setHSL(0.1, 1, 0.95);
        dirLight.position.set(-1, 1.75, 1);
        dirLight.position.multiplyScalar(30);
        scene.add(dirLight);

        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;

        const d = 50;

        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;

        dirLight.shadow.camera.far = 3500;
        dirLight.shadow.bias = -0.0001;

        const dirLightHelper = new THREE.DirectionalLightHelper(dirLight, 10);
        dirLight.visible = true;
        scene.add(dirLightHelper);

        // GROUND
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        groundMat.color.setHSL(0.095, 1, 0.75);

        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.position.z = 2;
        ground.position.y = 0;
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // SKYDOME

        const vertexShader = document.getElementById("vertexShader").textContent;
        const fragmentShader = document.getElementById("fragmentShader").textContent;
        const uniforms = {
          topColor: { value: new THREE.Color(0x0077ff) },
          bottomColor: { value: new THREE.Color(0xffffff) },
          offset: { value: 33 },
          exponent: { value: 0.6 },
        };
        uniforms["topColor"].value.copy(hemiLight.color);

        scene.fog.color.copy(uniforms["bottomColor"].value);

        const skyGeo = new THREE.SphereGeometry(4000, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          side: THREE.BackSide,
        });

        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);

        // RENDER OPTIONS

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        mapContainer.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 1;
        controls.maxDistance = 800;
        window.addEventListener("resize", onWindowResize);

        // STATS
        stats = new Stats();
        mapContainer.appendChild(stats.dom);

        getBuildings();
        //getSurroundings();
      }
*/
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        render();
        stats.update();
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
      }

      function render() {
        renderer.render(scene, camera);
      }

      function getBuildings() {
        fetch("./resources/db-logo.geojson").then((resp) => {
          resp.json().then((data) => {
            loadBuildings(data, center);
          });
        });
      }

      function loadBuildings(data, centerP) {
        data.features.forEach((element, index) => {
          if (!element["properties"]) return;

          if (element.geometry.type === "Polygon") {
            const building = new Building(element.geometry.coordinates, element.properties, centerP);
            const buildingGeom = building.generate();
            const material = new THREE.MeshBasicMaterial({ color: element.properties.fill });
            const meshBox = new THREE.Mesh(buildingGeom, material);
            meshBox.castShadow = true;
            meshBox.receiveShadow = true;
            scene.add(meshBox);
          }
        });
      }

      init();
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate();
    </script>
  </body>
</html>
